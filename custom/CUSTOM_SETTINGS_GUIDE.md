**Generated by AI after finally figuring out how to add custom settings**

General idea is to create a list of settings (QVariant) and overwrite the AppSettings to load them like this:
```
    ListModel {
        id: settingsPagesModel

        // below is the additional code to load custom settings pages
        // everything else is copied from QGroundControl/src/QmlControls/AppSettings.qml
        Component.onCompleted: {
            // Load standard settings pages
            var standardSettings = Qt.createComponent("qrc:/qml/QGroundControl/AppSettings/SettingsPagesModel.qml")
            if (standardSettings.status === Component.Ready) {
                var standardModel = standardSettings.createObject(settingsPagesModel)
                for (var i = 0; i < standardModel.count; i++) {
                    append(standardModel.get(i))
                }
            }
            
            // Add custom settings from plugin
            var customPages = QGroundControl.corePlugin.customSettingsPages
            for (var j = 0; j < customPages.length; j++) {
                var page = customPages[j]
                var pageVisibleFunc = function() { return true }
                append({
                    "name": page.title,
                    "url": page.url.toString(),
                    "iconUrl": page.icon.toString() || "qrc:/InstrumentValueIcons/gear.svg",
                    "pageVisible": pageVisibleFunc
                })
            }
        }
    }
```

# Custom Settings Implementation Guide

This document explains how to add custom settings pages to a QGroundControl custom build.

## Overview

QGC's settings framework uses the **Fact System** for parameter management. Custom builds can add their own settings pages that appear in the Application Settings menu alongside standard QGC settings (General, Fly View, Video, etc.).

## Architecture Flow

```
CustomPlugin
    └── CustomSettings (SettingsGroup)
            └── Facts (httpUrl, webSocketUrl)
                    └── Metadata (JSON file)

CustomPlugin exposes settings via Q_PROPERTY
    └── QML accesses via QGroundControl.corePlugin.customSettings
            └── UI binds to individual Facts
```

## Implementation Steps

### 1. Create Settings Group Class

**Files:**
- `custom/src/Settings/CustomSettings.h`
- `custom/src/Settings/CustomSettings.cc`

```cpp
// CustomSettings.h
class CustomSettings : public SettingsGroup
{
    Q_OBJECT
    DEFINE_SETTING_NAME_GROUP()
    DEFINE_SETTINGFACT(httpUrl)
    DEFINE_SETTINGFACT(webSocketUrl)
public:
    CustomSettings(QObject* parent = nullptr);
};

// CustomSettings.cc
DECLARE_SETTINGGROUP(Custom, "Custom")
{
    qmlRegisterUncreatableType<CustomSettings>("QGroundControl.SettingsManager", 1, 0, "CustomSettings", "Reference only");
}
DECLARE_SETTINGSFACT(CustomSettings, httpUrl)
DECLARE_SETTINGSFACT(CustomSettings, webSocketUrl)
```

**Key Points:**
- Class name must be `{Base}Settings` (e.g., `CustomSettings`)
- `DECLARE_SETTINGGROUP(Base, "GroupName")` - first param WITHOUT "Settings" suffix
- Macro automatically appends "Settings" to the base name

### 2. Create Metadata JSON

**File:** `custom/src/Settings/CustomSettings.SettingsGroup.json`

```json
{
    "version": 1,
    "fileType": "FactMetaData",
    "QGC.MetaData.Facts": [
        {
            "name": "httpUrl",
            "shortDesc": "Data collection HTTP Url",
            "longDesc": "HTTP url address and port...",
            "type": "string",
            "default": "0.0.0.0:5000"
        }
    ]
}
```

**Must be in Qt resources at:** `:/json/Custom.SettingsGroup.json`

### 3. Register in Qt Resources

**File:** `custom/custom.qrc`

```xml
<qresource prefix="/json">
    <file alias="Custom.SettingsGroup.json">src/Settings/CustomSettings.SettingsGroup.json</file>
</qresource>
```

**Critical:** Prefix must be `/json` (not `/Custom/json`), alias must match `{Base}.SettingsGroup.json`

### 4. Expose in CustomPlugin

**File:** `custom/src/CustomPlugin.h`

```cpp
class CustomPlugin : public QGCCorePlugin
{
    Q_OBJECT
    Q_PROPERTY(CustomSettings* customSettings READ customSettings CONSTANT)
    Q_PROPERTY(QVariantList customSettingsPages READ customSettingsPages CONSTANT)
    
    CustomSettings* customSettings() const { return _customSettings; }
    QVariantList customSettingsPages() const { return _customSettingsList; }
    
private:
    CustomSettings* _customSettings = nullptr;
    QVariantList _customSettingsList;
};
```

### 5. Initialize After QGCCorePlugin Ready

**File:** `custom/src/CustomPlugin.cc`

```cpp
QQmlApplicationEngine* CustomPlugin::createQmlApplicationEngine(QObject* parent)
{
    _qmlEngine = QGCCorePlugin::createQmlApplicationEngine(parent);
    
    // Initialize AFTER QGCCorePlugin is ready
    if (!_customSettings) {
        _customSettings = new CustomSettings(this);
        _addSettingsEntry(tr("Data Collection"), "qrc:/Custom/qml/CustomSettings.qml");
    }
    
    return _qmlEngine;
}
```

**Why here?** Initializing in constructor causes infinite recursion:
```
CustomPlugin() → new CustomSettings() → SettingsGroup() 
    → QGCCorePlugin::instance() → CustomPlugin::instance() 
    → new CustomSettings() → CRASH
```

### 6. Create Settings QML Page

**File:** `custom/src/CustomSettings.qml`

```qml
import QGroundControl
import QGroundControl.Controls
import QGroundControl.FactControls
import QGroundControl.AppSettings  // Required for SettingsPage

SettingsPage {
    property var _customSettings: QGroundControl.corePlugin.customSettings

    SettingsGroupLayout {
        Layout.fillWidth: true
        heading: qsTr("Server Configuration")
        
        LabelledFactTextField {
            label: qsTr("HTTP URL")
            fact: _customSettings ? _customSettings.httpUrl : null
        }
    }
}
```

### 7. Override AppSettings.qml (Optional)

To inject custom settings into the standard settings menu:

**File:** `custom/qml/AppSettings.qml`

```qml
ListModel {
    id: settingsPagesModel
    Component.onCompleted: {
        // Load standard settings
        var standardSettings = Qt.createComponent("qrc:/qml/QGroundControl/AppSettings/SettingsPagesModel.qml")
        if (standardSettings.status === Component.Ready) {
            var standardModel = standardSettings.createObject(settingsPagesModel)
            for (var i = 0; i < standardModel.count; i++) {
                append(standardModel.get(i))
            }
        }
        
        // Add custom pages
        var customPages = QGroundControl.corePlugin.customSettingsPages
        for (var j = 0; j < customPages.length; j++) {
            var page = customPages[j]
            append({
                "name": page.title,
                "url": page.url.toString(),
                "iconUrl": page.icon.toString() || "qrc:/InstrumentValueIcons/gear.svg",
                "pageVisible": function() { return true }
            })
        }
    }
}
```

**Register in custom.qrc:**
```xml
<qresource prefix="/Custom/qml">
    <file alias="QGroundControl/Controls/AppSettings.qml">qml/AppSettings.qml</file>
</qresource>
```

**How it works:** CustomPlugin's `CustomOverrideInterceptor` intercepts `qrc:/qml/QGroundControl/Controls/AppSettings.qml` and redirects to `qrc:/Custom/qml/QGroundControl/Controls/AppSettings.qml`

## Accessing Settings in C++

```cpp
#include "CustomPlugin.h"

void MyClass::someMethod() {
    CustomPlugin* plugin = qobject_cast<CustomPlugin*>(QGCCorePlugin::instance());
    if (plugin && plugin->customSettings()) {
        QString httpUrl = plugin->customSettings()->httpUrl()->rawValue().toString();
        // Use the value
    }
}
```

## Common Pitfalls

### 1. ❌ Initializing Settings in Constructor
```cpp
// WRONG - causes infinite recursion
CustomPlugin::CustomPlugin(QObject* parent)
    : QGCCorePlugin(parent)
    , _customSettings(new CustomSettings(this))  // ❌
{ }
```

### 2. ❌ Wrong JSON Resource Path
```xml
<!-- WRONG -->
<qresource prefix="/Custom/json">
    <file alias="CustomSettings.SettingsGroup.json">...</file>
</qresource>

<!-- CORRECT -->
<qresource prefix="/json">
    <file alias="Custom.SettingsGroup.json">...</file>
</qresource>
```

### 3. ❌ Class Naming Mismatch
```cpp
// If class is named CustomSettings, use:
DECLARE_SETTINGGROUP(Custom, "Custom")  // ✓ Correct

// NOT:
DECLARE_SETTINGGROUP(CustomSettings, "Custom")  // ❌ Wrong
```

### 4. ❌ Missing Q_PROPERTY
Without exposing via Q_PROPERTY, QML cannot access settings:
```cpp
// Must have this in CustomPlugin.h:
Q_PROPERTY(CustomSettings* customSettings READ customSettings CONSTANT)
```

### 5. ❌ Missing Import in QML
```qml
import QGroundControl.AppSettings  // Required for SettingsPage
```

## File Structure

```
custom/
├── custom.qrc                              # Resource file
├── src/
│   ├── Settings/
│   │   ├── CustomSettings.h                # Settings class
│   │   ├── CustomSettings.cc               # Settings implementation
│   │   └── CustomSettings.SettingsGroup.json  # Metadata
│   ├── CustomSettings.qml                  # Settings UI page
│   └── CustomPlugin.{h,cc}                 # Plugin with Q_PROPERTY
└── qml/
    └── AppSettings.qml                     # Override standard settings menu
```

## Key Principles

1. **Fact System** - Always use for parameters (type-safe, persistent, unit conversion)
2. **Lazy Initialization** - Create settings after plugin singleton is ready
3. **Resource Paths** - JSON at `/json/{Base}.SettingsGroup.json`, QML can be anywhere
4. **QML Exposure** - Use Q_PROPERTY to expose C++ objects to QML
5. **Defensive Coding** - Always null-check in QML (`fact: _customSettings ? _customSettings.httpUrl : null`)

## Testing

1. Build: `cmake --build build --config Debug`
2. Run: `./build/Debug/Custom-QGroundControl`
3. Navigate to: Application Settings → Data Collection
4. Verify: Settings fields appear and values persist between sessions

## Persistence

Settings automatically persist via Qt's `QSettings` mechanism. No additional code needed - the Fact System handles it automatically based on the JSON metadata.
